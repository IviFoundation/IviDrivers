# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml
trigger:
- dk/SharedComponents
pool:
  vmImage: 'windows-2022'
variables:
  Project_Name: 'IviDriverNet/1.0/Code/Ivi.DriverCore/Ivi.DriverCore.csproj'
  NuGetConfigPath: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/nuget.config'
  MajorVersion: '1'
  MinorVersion: '0'
  PackageOutputPath: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/build/Release'
  FeedUrl: 'https://ivifoundation.pkgs.visualstudio.com/IVI/_packaging/Test3/nuget/v3/index.json'  # Feed URL for NuGet package
  ApiKey: 'az'  # Placeholder for API key, replace if necessary
stages:
- stage: stage_build
  displayName: 'Build and Unit Test'
  jobs:
  - job: job_build
    displayName: 'Build and Unit Test'
    steps:
    - checkout: self
      persistCredentials: true  # enables git tag/push later
      submodules: true
    # Authenticate NuGet Feed
    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'
    - task: DownloadSecureFile@1
      name: StrongName
      displayName: 'Download IVI private key'
      inputs:
        secureFile: ce8dd88f-9893-442d-abe2-a7819b937b73
 
    - task: AzureKeyVault@2
      displayName: 'Get secrets from Azure Key Vault'
      inputs:
        connectedServiceName: 'Azure for IVI'
        KeyVaultName: 'ivi-prod-kv'
        SecretsFilter: 'SigningKeyVaultUri,SigningClientId,SigningClientSecret,SigningCertName,SigningTenantId'
        RunAsPreJob: true      
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '8.x'        
    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'  
    - task: NuGetToolInstaller@1
      displayName: 'Use NuGet 6.0.0'
      inputs:
        versionSpec: 6.0.0
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          $major = $(MajorVersion)
          $minor = $(MinorVersion)
          $build = $(Build.BuildId)
          $version = "$major.$minor.$build"
          Write-Host "##vso[task.setvariable variable=PackageVersion]$version"
          Write-Host "Generated Version: $version"
      displayName: 'Generate Unique Version'
    - task: DotNetCoreCLI@2
      displayName: Install Tools
      inputs:
        command: 'custom'
        custom: 'tool'
        arguments: 'restore'
    - task: NuGetCommand@2
      displayName: 'NuGet restore'
      inputs:
        solution: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/Ivi.DriverCore/Ivi.DriverCore.csproj'
        selectOrConfig: config
        nugetConfigPath: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/nuget.config'
    - task: MSBuild@1
      inputs:
        solution: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/Ivi.DriverCore/Ivi.DriverCore.csproj'
        msbuildArchitecture: 'x64'
        configuration: 'Release'
        msbuildArguments: '/p:Configuration=Release /p:Version=$(PackageVersion)'
      displayName: 'Build Project with MSBuild'

  
# Install Azure Sign Tool 
    - task: PowerShell@2
      displayName: 'Install AzureSignTool'
      inputs:
        targetType: 'inline'
        script: |
          if (!(Get-Command azuresigntool -ErrorAction SilentlyContinue)) {
              Write-Host "Installing AzureSignTool globally..."
              dotnet tool install --global AzureSignTool
          } else {
              Write-Host "AzureSignTool is already installed."
          }
          # add .NET global tools path to PATH for immediate usage
          $env:Path += ";$env:USERPROFILE\.dotnet\tools"
          [System.Environment]::SetEnvironmentVariable("PATH", $env:Path, [System.EnvironmentVariableTarget]::Process)
 
    # Sign DLLs using Start-Process
    - task: PowerShell@2
      displayName: 'Sign DLLs with AzureSignTool'
      inputs:
        targetType: 'inline'
        script: |
          # Install AzureSignTool
          dotnet tool install --global AzureSignTool
          $env:Path += ";$env:USERPROFILE\.dotnet\tools"
    
          # Ensure AzureSignTool is installed
          $signTool = "AzureSignTool"
          if (!(Get-Command $signTool -ErrorAction SilentlyContinue)) {
              Write-Error "$signTool not found. Ensure it is installed."
              exit 1
          }
    
          # Set signing parameters
          $signParams = @{
              KeyVaultUrl      = "$(SigningKeyVaultUri)"
              ClientId         = "$(SigningClientId)"
              TenantId         = "$(SigningTenantId)"
              ClientSecret     = "$(SigningClientSecret)"
              CertificateName  = "$(SigningCertName)"
              TimestampUrl     = "http://timestamp.digicert.com"
              DigestAlgorithm  = "sha256"
          }
    
          # Get all DLLs to sign
          $dllPaths = Get-ChildItem -Path "$(PackageOutputPath)" -Recurse -Filter *.dll
          if (!$dllPaths) {
              Write-Error "No DLLs found to sign."
              exit 1
          }
    
          foreach ($dll in $dllPaths) {
            AzureSignTool sign $dll.FullName --file-digest $signParams.DigestAlgorithm --timestamp-rfc3161 $signParams.TimestampUrl --timestamp-digest $signParams.DigestAlgorithm --azure-key-vault-url $signParams.KeyVaultUrl --azure-key-vault-client-id $signParams.ClientId --azure-key-vault-tenant-id $signParams.TenantId --azure-key-vault-client-secret $signParams.ClientSecret --azure-key-vault-certificate $signParams.CertificateName
    
            if ($LASTEXITCODE -ne 0) {
                Write-Error "DLL signing failed: $($dll.FullName)"
                exit $LASTEXITCODE
            }
          }
      condition: and(succeeded(), ne(variables['SigningCertName'], ''))

# Pack Signed DLLs into NuGet Package# Pack Signed DLLs into a NuGet Package
    - task: DotNetCoreCLI@2
      displayName: 'Pack NuGet Package'
      inputs:
        command: 'pack'
        packagesToPack: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/Ivi.DriverCore/Ivi.DriverCore.csproj'
        packDirectory: '$(PackageOutputPath)'
        versioningScheme: 'byEnvVar'
        versionEnvVar: 'PackageVersion'
        
        
    - task: UseDotNet@2
      displayName: 'Install .NET 6 SDK'
      inputs:
        packageType: 'sdk'
        version: '6.x'
    # Step 7: Run Unit Test   
    - task: NuGetCommand@2
      displayName: 'NuGet Restore for Test Project (.NET 6)'
      inputs:
        restoreSolution: false
        feedsToUse: config
        nugetConfigPath: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/nuget.config'
        restoreArguments: 'IviDriverNet/1.0/Code/IviDriverCoreTests/IviDriverCoreTests.csproj -p:TargetFramework=net6.0'

    # Run Unit Tests for IviDriverCoreTests.csproj using .NET 6
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests '
      inputs:
        command: test
        projects: 'IviDriverNet/1.0/Code/IviDriverCoreTests/IviDriverCoreTests.csproj'
        arguments: '--configuration Release --framework net6.0' 
 
    - task: PowerShell@2
      displayName: 'Sign NuGet Packages'
      inputs:
        targetType: 'inline'
        script: |
          # Install NuGetKeyVaultSignTool
          dotnet tool install --global NuGetKeyVaultSignTool
          $env:Path += ";$env:USERPROFILE\.dotnet\tools"
          # Ensure the tool is installed
          $nugetSignTool = "NuGetKeyVaultSignTool"
          if (!(Get-Command $nugetSignTool -ErrorAction SilentlyContinue)) {
              Write-Error "$nugetSignTool not found. Ensure it is installed."
              exit 1
          }
          # Set signing parameters
          $signParams = @{
              KeyVaultUrl      = "$(SigningKeyVaultUri)"
              ClientId         = "$(SigningClientId)"
              TenantId         = "$(SigningTenantId)"
              ClientSecret     = "$(SigningClientSecret)"
              CertificateName  = "$(SigningCertName)"
              TimestampUrl     = "http://timestamp.digicert.com"
              DigestAlgorithm  = "sha256"
          }
          # Get all NuGet packages
          $nupkgPaths = Get-ChildItem -Path "$(PackageOutputPath)" -Filter *.nupkg
          if (!$nupkgPaths) {
              Write-Error "No NuGet packages found to sign."
              exit 1
          }
          foreach ($nupkgPath in $nupkgPaths) {
            NuGetKeyVaultSignTool sign $nupkgPath.FullName --file-digest $signParams.DigestAlgorithm --timestamp-rfc3161 $signParams.TimestampUrl --timestamp-digest $signParams.DigestAlgorithm --azure-key-vault-url $signParams.KeyVaultUrl  --azure-key-vault-client-id $signParams.ClientId  --azure-key-vault-tenant-id $signParams.TenantId  --azure-key-vault-client-secret $signParams.ClientSecret   --azure-key-vault-certificate $signParams.CertificateName
              if ($LASTEXITCODE -ne 0) {
                  Write-Error "NuGet package signing failed: $($nupkgPath.FullName)"
                  exit $LASTEXITCODE
              }
          }
      condition: and(succeeded(), ne(variables['SigningCertName'], ''))

    - task: PowerShell@2
      displayName: 'Create Drop Folder and Copy NuGet Package'
      inputs:
        targetType: 'inline'
        script: |
          $dropFolder = "$(Build.ArtifactStagingDirectory)\drop"
          if (!(Test-Path $dropFolder)) {
              New-Item -ItemType Directory -Path $dropFolder | Out-Null
          }
          Copy-Item "$(PackageOutputPath)\*.nupkg" -Destination $dropFolder -Force
 
    - task: PublishPipelineArtifact@1
      displayName: 'Publish NuGet Package'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)\drop'
        artifactName: 'drop'
        publishLocation: 'pipeline'      
  # Publish Nuget package to Azure Artifacts
    - task: NuGetAuthenticate@1
      displayName: 'Authenticate to Azure Artifacts'
 
    - task: NuGetCommand@2
      displayName: 'NuGet restore'
      inputs:
        solution: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/Ivi.DriverCore/Ivi.DriverCore.csproj'
        selectOrConfig: config
        nugetConfigPath: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/nuget.config'
 
    - task: NuGetCommand@2
      displayName: 'Push NuGet Package to Azure Artifacts'
      inputs:
        command: 'push'
        packagesToPush: '$(Build.ArtifactStagingDirectory)/drop/*.nupkg'
        publishVstsFeed: 'IVI/Test3'
        allowPackageConflicts: false
        nuGetFeedType: internal
 
  # Run the Integration test

- stage: stage_integration_test
  displayName: 'Integration Test'
  dependsOn: stage_build
  condition: succeeded()
  jobs:
    - job: job_integration_test
      displayName: 'Run Integration Tests'
      steps:
        # Authenticate NuGet before running tests
        - task: NuGetAuthenticate@1
          displayName: 'NuGet Authenticate for Tests'

        - task: NuGetCommand@2
          displayName: 'NuGet Restore for Test Project (.NET 6)'
          inputs:
            restoreSolution: false
            feedsToUse: config
            nugetConfigPath: '$(Build.SourcesDirectory)/IviDriverNet/1.0/Code/nuget.config'
            restoreArguments: 'IviDriverNet/1.0/Code/IviDriverCoreTests/IviDriverCoreTests.csproj -p:TargetFramework=net6.0'

        # Run Unit Tests for IviDriverCoreTests.csproj using .NET 6
        - task: DotNetCoreCLI@2
          displayName: 'Run Unit Tests '
          inputs:
            command: test
            projects: 'IviDriverNet/1.0/Code/IviDriverCoreTests/IviDriverCoreTests.csproj'
            arguments: '--configuration Release --framework net6.0' 
 
 
- stage: stage_release_dev
  displayName: 'Release to Dev'
  dependsOn: 
    - stage_build
    - stage_integration_test
  condition: succeeded()  # Ensure this stage always runs if previous stages succeed
  jobs:
    - job: dummy_release_dev
      displayName: 'Dummy Release to Dev'
      steps:
        - script: echo "Dummy stage for Release to Dev executed successfully."
          displayName: 'Dummy Step - Dev Release'
 
- stage: stage_release_prod
  displayName: 'Release to Prod'
  dependsOn: stage_release_dev
  condition: succeeded()  # Ensure this stage always runs if the previous stage succeeds
  jobs:
    - job: dummy_release_prod
      displayName: 'Dummy Release to Prod'
      steps:
        - script: echo "Dummy stage for Release to Prod executed successfully."
          displayName: 'Dummy Step - Prod Release'